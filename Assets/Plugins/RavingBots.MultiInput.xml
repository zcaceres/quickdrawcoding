<?xml version="1.0"?>
<doc>
    <assembly>
        <name>RavingBots.MultiInput</name>
    </assembly>
    <members>
        <member name="T:RavingBots.MultiInput.DeviceEvent">
            <summary>
                Enumeration for device state events.
            </summary>
            <seealso cref="F:RavingBots.MultiInput.InputState.DeviceStateChanged" />
        </member>
        <member name="F:RavingBots.MultiInput.DeviceEvent.Created">
            <summary>
                The device object has been created (i.e. a new device has been detected).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.DeviceEvent.Removed">
            <summary>
                The device object has been removed (i.e. the device is no longer present in the system).
                You should discard the affected device object, it will no longer be present on the
                <see cref="P:RavingBots.MultiInput.InputState.Devices" /> list.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.DeviceEvent.Unusable">
            <summary>
                The device has been marked unusable and will no longer produce usable input.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.DeviceEvent.Usable">
            <summary>
                The device has been marked usable and will produce usable input again.
            </summary>
        </member>
        <member name="T:RavingBots.MultiInput.DevicesEnumeratedEvent">
            <summary>
                Event type for the <see cref="F:RavingBots.MultiInput.InputState.DevicesEnumerated" /> event.
            </summary>
        </member>
        <member name="T:RavingBots.MultiInput.DeviceStateChangedEvent">
            <summary>
                Event type for the <see cref="F:RavingBots.MultiInput.InputState.DeviceStateChanged" /> event.
                You will get a device object and the enumerator describing the change.
                The device object may be <c>null</c> for removed devices.
            </summary>
        </member>
        <member name="T:RavingBots.MultiInput.IDevice">
            <summary>
                Uniform interface to all device objects.
            </summary>
            <remarks>
                This interface is one of the two core abstractions in Multi-Input (the other one
                being <see cref="T:RavingBots.MultiInput.IVirtualAxis" />). Most of your interaction with this library will
                be through device objects and this interface.
                <note type="note">
                    We plan to make comprehensive API for extending the library with your own devices,
                    but all of the internal machinery is still in flux and might change as we expand the
                    device and platform support.
                </note>
            </remarks>
            <threadsafety static="false" instance="false" />
        </member>
        <member name="P:RavingBots.MultiInput.IDevice.Id">
            <summary>
                A session-unique ID of this device.
            </summary>
            <remarks>
                <para>
                    This ID is not persistent. You must not store it, or
                    expect any particular device to always have the same ID.
                </para>
            </remarks>
        </member>
        <member name="P:RavingBots.MultiInput.IDevice.Name">
            <summary>
                Friendly name of this device.
            </summary>
            <remarks>
                <para>
                    Might be empty, but will never be null.
                </para>
                <note type="important">
                    This value can only be used if <see cref="P:RavingBots.MultiInput.IDevice.IsUsable"/> is <c>true</c>.
                </note>
            </remarks>
        </member>
        <member name="P:RavingBots.MultiInput.IDevice.Location">
            <summary>
                Value describing the bus location of the device.
            </summary>
            <remarks>
                <para>
                    Might be empty, but will never be null.
                </para>
                <para>
                    Can be used to try to determine (on best-effort basis) whether device
                    that just reconnected is the same one the player has been using.
                </para>
                <para>
                    However, it's NOT guaranteed to be useful, unique or persistent.
                    It highly depends on the OS, the driver and the device. It's very likely
                    that you will have multiple devices sharing the same Location value. Make
                    sure your code can handle that.
                </para>
                <para>
                    Don't try to parse or display this value. The only meaningful thing you can do with
                    it is to compare it with a Location property of another device.
                </para>
                <note type="important">
                    This value can only be used if <see cref="P:RavingBots.MultiInput.IDevice.IsUsable"/> is <c>true</c>.
                </note>
            </remarks>
        </member>
        <member name="P:RavingBots.MultiInput.IDevice.InternalName">
            <summary>
                Value containing internal name/ID of the device reported by the OS.
            </summary>
            <remarks>
                <para>Might be empty, but will never be null.</para>
                <para>
                    Don't try to parse or display this value. The only meaningful thing you can do with
                    it is to compare it with a InternalName property of another device.
                </para>
                <note type="important">
                    This value can only be used if <see cref="P:RavingBots.MultiInput.IDevice.IsUsable"/> is <c>true</c>.
                </note>
            </remarks>
        </member>
        <member name="P:RavingBots.MultiInput.IDevice.VendorId">
            <summary>
                Vendor ID reported by the device/driver.
            </summary>
            <remarks>
                <para>Might be zero.</para>
                <note type="important">
                    This value can only be used if <see cref="P:RavingBots.MultiInput.IDevice.IsUsable"/> is <c>true</c>.
                </note>
            </remarks>
        </member>
        <member name="P:RavingBots.MultiInput.IDevice.ProductId">
            <summary>
                Product ID reported by the device/driver.
            </summary>
            <remarks>
                <para>Might be zero.</para>
                <note type="important">
                    This value can only be used if <see cref="P:RavingBots.MultiInput.IDevice.IsUsable"/> is <c>true</c>.
                </note>
            </remarks>
        </member>
        <member name="P:RavingBots.MultiInput.IDevice.Revision">
            <summary>
                Revision/version reported by the device/driver.
            </summary>
            <remarks>
                <para>Might be zero.</para>
                <note type="important">
                    This value can only be used if <see cref="P:RavingBots.MultiInput.IDevice.IsUsable"/> is <c>true</c>.
                </note>
            </remarks>
        </member>
        <member name="P:RavingBots.MultiInput.IDevice.Serial">
            <summary>
                Serial number reported by the device/driver.
            </summary>
            <remarks>
                <para>Might be empty, but will never be null.</para>
            </remarks>
        </member>
        <member name="P:RavingBots.MultiInput.IDevice.IsUsable">
            <summary>
                <c>true</c> if device is usable. The exact meaning of this is device-specific,
                but unusable devices should not be considered when checking for input.
            </summary>
        </member>
        <member name="P:RavingBots.MultiInput.IDevice.CanVibrate">
            <summary>
                <c>true</c> if device supports vibration.
            </summary>
            <remarks>
                If this is <c>false</c>, <see cref="M:RavingBots.MultiInput.IDevice.Vibrate(System.Int32,System.Single,System.Single)" /> is a no-op and always returns <c>false</c>.
            </remarks>
        </member>
        <member name="P:RavingBots.MultiInput.IDevice.Item(RavingBots.MultiInput.InputCode)">
            <summary>
                Returns a virtual axis object or <c>null</c> if the axis is not supported by this device.
            </summary>
            <remarks>
                Devices are allowed to claim support for axes but never report any values on them.
            </remarks>
            <param name="code">Code of the axis.</param>
        </member>
        <member name="P:RavingBots.MultiInput.IDevice.SupportedAxes">
            <summary>
                Enumerable of all axes this device supports.
            </summary>
        </member>
        <member name="M:RavingBots.MultiInput.IDevice.Vibrate(System.Int32,System.Single,System.Single)">
            <preliminary>
                This method is currently designed for XBox-compatible controllers. The vibration API might still change
                as we expand the device and platform support.
            </preliminary>
            <summary>
                Makes this device vibrate for specified amount of time.
            </summary>
            <param name="duration">Duration of the effect, in milliseconds.</param>
            <param name="left">Strength of the left motor vibration, in range <c>[0, 1]</c>. 0 immediately turns the motor off.</param>
            <param name="right">Strength of the right motor vibration, in range <c>[0, 1]</c>. 0 immediately turns the motor off.</param>
            <returns>
                <c>true</c> if the signal was sent successfully to the device
                (not necessarily that the device acted on it).
            </returns>
        </member>
        <member name="M:RavingBots.MultiInput.IDevice.Reset">
            <summary>
                Resets the state of all axes on this device.
            </summary>
        </member>
        <member name="T:RavingBots.MultiInput.InputCode">
            <summary>
                Platform- and device-independent virtual axis codes.
            </summary>
            <remarks>
                <para>
                    This enumeration is guaranteed to be forward- and backward-compatible,
                    and so can be safely serialized. <see cref="T:RavingBots.MultiInput.InputCodeExt" /> contains few utility
                    extension methods related to <c>InputCode</c>.
                </para>
                <para>
                    Not all codes present here will actually
                    be reported — it highly depends on what the OS and the actual device supports. You should
                    keep that in mind when determining default controls for your game.
                </para>
                <note type="important">
                    Keyboard codes are based on US International layout. There are several so-called OEM keys which might have
                    different
                    purpose on some layouts (those will be marked in remarks). We currently don't process or expose keyboard layout
                    information,
                    only report the codes as-is, based on what we get from the OS.
                    This might affect accuracy of UI when presenting the keys based on the input codes in localized settings.
                </note>
                <para>
                    There are three enumerator value ranges:
                    <list type="bullet">
                        <item>
                            All keyboard codes have values between <see cref="F:RavingBots.MultiInput.InputCodeExt.KeyboardRangeStart" /> and
                            <see cref="F:RavingBots.MultiInput.InputCodeExt.KeyboardRangeEnd" /> (inclusive).
                        </item>
                        <item>
                            All mouse codes have values between <see cref="F:RavingBots.MultiInput.InputCodeExt.MouseRangeStart" /> and
                            <see cref="F:RavingBots.MultiInput.InputCodeExt.MouseRangeStart" /> (inclusive).
                        </item>
                        <item>
                            All gamepad codes have values between <see cref="F:RavingBots.MultiInput.InputCodeExt.PadRangeStart" /> and
                            <see cref="F:RavingBots.MultiInput.InputCodeExt.PadRangeStart" /> (inclusive).
                        </item>
                    </list>
                </para>
                <para>
                    Additionally, three subranges are available for your use, if you need to store
                    custom codes:
                </para>
                <list type="bullet">
                    <item>
                        Custom keyboard codes should have values between <see cref="F:RavingBots.MultiInput.InputCodeExt.KeyboardCustomRangeStart" /> and
                        <see cref="F:RavingBots.MultiInput.InputCodeExt.KeyboardRangeEnd" /> (inclusive).
                    </item>
                    <item>
                        Custom mouse codes have should values between <see cref="F:RavingBots.MultiInput.InputCodeExt.MouseCustomRangeStart" /> and
                        <see cref="F:RavingBots.MultiInput.InputCodeExt.MouseRangeStart" /> (inclusive).
                    </item>
                    <item>
                        Custom gamepad codes have should values between <see cref="F:RavingBots.MultiInput.InputCodeExt.PadCustomRangeStart" /> and
                        <see cref="F:RavingBots.MultiInput.InputCodeExt.PadRangeStart" /> (inclusive).
                    </item>
                </list>
                <para>
                    Axes representing digital buttons always report 0 or 1 value. Other axes will report scalar floating point
                    values.
                    The range of analog axis values depends on the axis (for example <see cref="F:RavingBots.MultiInput.InputCode.MouseX" /> range is unbounded, and
                    <see cref="F:RavingBots.MultiInput.InputCode.PadLeftStickX" /> range is <c>[-1, 1]</c>) — see the description of the enumerator for details.
                    Range notation has been used throughout this document as a shorthand:
                </para>
                <list type="bullet">
                    <item><c>[x, y]</c> means "from x (inclusive) to y (inclusive)"</item>
                    <item><c>[x, y)</c> means "from x (inclusive) to y (exclusive)"</item>
                    <item><c>(x, y]</c> means "from x (exclusive) to y (inclusive)"</item>
                    <item><c>(x, y)</c> means "from x (exclusive) to y (exclusive)"</item>
                </list>
            </remarks>
            <seealso cref="T:RavingBots.MultiInput.InputCodeExt" />
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.None">
            <summary>
                Value reserved for unknown codes or uninitialized variables.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.Key0">
            <summary>
                The <c>0</c> key (alphanumeric).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.Key1">
            <summary>
                The <c>1</c> key (alphanumeric).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.Key2">
            <summary>
                The <c>2</c> key (alphanumeric).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.Key3">
            <summary>
                The <c>3</c> key (alphanumeric).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.Key4">
            <summary>
                The <c>4</c> key (alphanumeric).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.Key5">
            <summary>
                The <c>5</c> key (alphanumeric).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.Key6">
            <summary>
                The <c>6</c> key (alphanumeric).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.Key7">
            <summary>
                The <c>7</c> key (alphanumeric).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.Key8">
            <summary>
                The <c>8</c> key (alphanumeric).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.Key9">
            <summary>
                The <c>9</c> key (alphanumeric).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyA">
            <summary>
                The <c>A</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyB">
            <summary>
                The <c>B</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyC">
            <summary>
                The <c>C</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyD">
            <summary>
                The <c>D</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyE">
            <summary>
                The <c>E</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF">
            <summary>
                The <c>F</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyG">
            <summary>
                The <c>G</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyH">
            <summary>
                The <c>H</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyI">
            <summary>
                The <c>I</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyJ">
            <summary>
                The <c>J</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyK">
            <summary>
                The <c>K</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyL">
            <summary>
                The <c>L</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyM">
            <summary>
                The <c>M</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyN">
            <summary>
                The <c>N</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyO">
            <summary>
                The <c>O</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyP">
            <summary>
                The <c>P</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyQ">
            <summary>
                The <c>Q</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyR">
            <summary>
                The <c>R</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyS">
            <summary>
                The <c>S</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyT">
            <summary>
                The <c>T</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyU">
            <summary>
                The <c>U</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyV">
            <summary>
                The <c>V</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyW">
            <summary>
                The <c>W</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyX">
            <summary>
                The <c>X</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyY">
            <summary>
                The <c>Y</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyZ">
            <summary>
                The <c>Z</c> key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeySemicolon">
            <summary>
                The OEM 1 key: <c>;</c> (semicolon) and <c>:</c> (colon) on the US International layout.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeySlash">
            <summary>
                The OEM 2 key: <c>/</c> (slash) and <c>?</c> (question mark) on the US International layout.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyAccent">
            <summary>
                The OEM 3 key: <c>`</c> (grave accent/backtick) and <c>~</c> (tilde) on the US International layout.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyLeftBracket">
            <summary>
                The OEM 4 key: <c>[</c> (left bracket) and <c>{</c> (left brace) on the US International layout.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyBackslash">
            <summary>
                The OEM 5 key: <c>\</c> (backslash) and <c>|</c> (vertical bar/pipe) on the US International layout.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyRightBracket">
            <summary>
                The OEM 6 key: <c>]</c> (right bracket) and <c>}</c> (right brace) on the US International layout.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyQuote">
            <summary>
                The OEM 7 key: <c>'</c> (apostrophe/single quote) and <c>"</c> (double quote) on the US International layout.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyOem8">
            <summary>
                The OEM 8 key: not present on the US International layout.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyOem102">
            <summary>
                The OEM 102 key: additional <see cref="F:RavingBots.MultiInput.InputCode.KeyBackslash" /> on the US International layout.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyBackspace">
            <summary>
                The Backspace key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyTab">
            <summary>
                The Tab key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyClear">
            <summary>
                The Clear key (Apple keyboards).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyEnter">
            <summary>
                The primary Enter key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyEscape">
            <summary>
                The Escape key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeySpace">
            <summary>
                The Space key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyPlus">
            <summary>
                The OEM plus key: <c>+</c> (plus sign) and <c>=</c> (equals sign) on the US International layout.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyComma">
            <summary>
                The OEM comma key: <c>,</c> (comma) and <c>&lt;</c> (left angle bracket) on the US International layout.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyMinus">
            <summary>
                The OEM minus key: <c>-</c> (minus sign) and <c>_</c> (underscore) on the US International layout.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyPeriod">
            <summary>
                The OEM period key: <c>.</c> (period/full stop) and <c>&gt;</c> (right angle bracket) on the US International
                layout.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyNum0">
            <summary>
                The <c>0</c> key (numeric pad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyNum1">
            <summary>
                The <c>1</c> key (numeric pad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyNum2">
            <summary>
                The <c>2</c> key (numeric pad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyNum3">
            <summary>
                The <c>3</c> key (numeric pad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyNum4">
            <summary>
                The <c>4</c> key (numeric pad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyNum5">
            <summary>
                The <c>5</c> key (numeric pad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyNum6">
            <summary>
                The <c>6</c> key (numeric pad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyNum7">
            <summary>
                The <c>7</c> key (numeric pad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyNum8">
            <summary>
                The <c>8</c> key (numeric pad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyNum9">
            <summary>
                The <c>9</c> key (numeric pad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyNumDecimal">
            <summary>
                The decimal key (numeric pad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyNumDivide">
            <summary>
                The <c>/</c> (divide) key (numeric pad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyNumMultiply">
            <summary>
                The <c>*</c> (multiply) key (numeric pad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyNumMinus">
            <summary>
                The <c>-</c> (subtract) key (numeric pad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyNumPlus">
            <summary>
                The <c>+</c> (add) key (numeric pad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyNumEnter">
            <summary>
                The Enter key (numeric pad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyUpArrow">
            <summary>
                The up arrow key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyDownArrow">
            <summary>
                The down arrow key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyRightArrow">
            <summary>
                The right arrow key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyLeftArrow">
            <summary>
                The left arrow key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyInsert">
            <summary>
                The Insert key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyDelete">
            <summary>
                The Delete key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyHome">
            <summary>
                The Home key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyEnd">
            <summary>
                The End key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyPageUp">
            <summary>
                The Page Up key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyPageDown">
            <summary>
                The Page Down key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF1">
            <summary>
                The F1 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF2">
            <summary>
                The F2 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF3">
            <summary>
                The F3 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF4">
            <summary>
                The F4 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF5">
            <summary>
                The F5 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF6">
            <summary>
                The F6 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF7">
            <summary>
                The F7 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF8">
            <summary>
                The F8 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF9">
            <summary>
                The F9 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF10">
            <summary>
                The F10 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF11">
            <summary>
                The F11 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF12">
            <summary>
                The F12 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF13">
            <summary>
                The F13 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF14">
            <summary>
                The F14 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF15">
            <summary>
                The F15 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF16">
            <summary>
                The F16 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF17">
            <summary>
                The F17 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF18">
            <summary>
                The F18 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF19">
            <summary>
                The F19 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF20">
            <summary>
                The F20 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF21">
            <summary>
                The F21 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF22">
            <summary>
                The F22 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF23">
            <summary>
                The F23 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyF24">
            <summary>
                The F24 key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyRightShift">
            <summary>
                The right Shift key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyLeftShift">
            <summary>
                The left Shift key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyRightAlt">
            <summary>
                The right Alt (Option on Apple keyboards) key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyLeftAlt">
            <summary>
                The left Alt (Option on Apple keyboards) key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyRightControl">
            <summary>
                The right Control key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyLeftControl">
            <summary>
                The left Control key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyRightCommand">
            <summary>
                The right Windows (Command on Apple keyboards) key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyLeftCommand">
            <summary>
                The left Windows (Command on Apple keyboards) key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyApps">
            <summary>
                The Application key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyPrintScreen">
            <summary>
                The Print Screen key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyPause">
            <summary>
                The Pause key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyCapsLock">
            <summary>
                The CapsLock key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyNumLock">
            <summary>
                The NumLock key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.KeyScrollLock">
            <summary>
                The ScrollLock key.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.MouseLeft">
            <summary>
                The left mouse button.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.MouseRight">
            <summary>
                The right mouse button.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.MouseMiddle">
            <summary>
                The middle mouse button.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.MouseFourth">
            <summary>
                The fourth mouse button.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.MouseFifth">
            <summary>
                The fifth mouse button.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.MouseSixth">
            <summary>
                The sixth mouse button.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.MouseSeventh">
            <summary>
                The seventh mouse button.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.MouseXLeft">
            <summary>
                The derived mouse <c>X-</c> axis. Value is relative mouse movement to the left.
                Range <c>[0, <see cref="F:System.Single.MaxValue">MaxValue</see>]</c>.
            </summary>
            <seealso cref="F:RavingBots.MultiInput.InputCode.MouseX" />
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.MouseXRight">
            <summary>
                The derived mouse <c>X+</c> axis. Value is relative mouse movement to the right.
                Range <c>[0, <see cref="F:System.Single.MaxValue">MaxValue</see>]</c>.
            </summary>
            <seealso cref="F:RavingBots.MultiInput.InputCode.MouseX" />
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.MouseYUp">
            <summary>
                The derived mouse <c>Y+</c> axis. Value is relative mouse movement away from the user.
                Range <c>[0, <see cref="F:System.Single.MaxValue">MaxValue</see>]</c>.
            </summary>
            <seealso cref="F:RavingBots.MultiInput.InputCode.MouseX" />
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.MouseYDown">
            <summary>
                The derived mouse <c>Y-</c> axis. Value is relative mouse movement towards the user.
                Range <c>[0, <see cref="F:System.Single.MaxValue">MaxValue</see>]</c>.
            </summary>
            <seealso cref="F:RavingBots.MultiInput.InputCode.MouseY" />
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.MouseWheelUp">
            <summary>
                The derived mouse <c>Z+</c> axis (the wheel). Value is relative mouse movement away from the user.
                Range <c>[0, <see cref="F:System.Single.MaxValue">MaxValue</see>]</c>.
            </summary>
            <seealso cref="F:RavingBots.MultiInput.InputCode.MouseWheel" />
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.MouseWheelDown">
            <summary>
                The derived mouse <c>Z-</c> axis (the wheel). Value is relative mouse movement towards the user.
                Range <c>[0, <see cref="F:System.Single.MaxValue">MaxValue</see>]</c>.
            </summary>
            <seealso cref="F:RavingBots.MultiInput.InputCode.MouseWheel" />
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.MouseX">
            <summary>
                The mouse X axis. Value is relative horizontal mouse movement. Unbounded range
                (<c>[<see cref="F:System.Single.MinValue">MinValue</see>, <see cref="F:System.Single.MaxValue">MaxValue</see>]</c>).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.MouseY">
            <summary>
                The mouse Y axis. Value is relative vertical mouse movement. Unbounded range
                (<c>[<see cref="F:System.Single.MinValue">MinValue</see>, <see cref="F:System.Single.MaxValue">MaxValue</see>]</c>).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.MouseWheel">
            <summary>
                The mouse Z axis (the wheel). Value is relative wheel movement. Unbounded range
                (<c>[<see cref="F:System.Single.MinValue">MinValue</see>, <see cref="F:System.Single.MaxValue">MaxValue</see>]</c>).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadLeftStickUp">
            <summary>
                The derived left analog stick Y+ axis. Non-zero when stick moved up/away from the user.
                Range <c>[0, 1]</c>.
            </summary>
            <seealso cref="F:RavingBots.MultiInput.InputCode.PadLeftStickY" />
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadLeftStickDown">
            <summary>
                The derived left analog stick Y- axis. Non-zero when stick moved down/towards from the user.
                Range <c>[0, 1]</c>.
            </summary>
            <seealso cref="F:RavingBots.MultiInput.InputCode.PadLeftStickY" />
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadLeftStickLeft">
            <summary>
                The derived left analog stick X- axis. Non-zero when stick moved to the left.  Range <c>[0, 1]</c>.
            </summary>
            <seealso cref="F:RavingBots.MultiInput.InputCode.PadLeftStickX" />
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadLeftStickRight">
            <summary>
                The derived left analog stick X+ axis. Non-zero when stick moved to the right.  Range <c>[0, 1]</c>.
            </summary>
            <seealso cref="F:RavingBots.MultiInput.InputCode.PadLeftStickX" />
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadLeftStick">
            <summary>
                The gamepad left stick digital button.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadLeftStickX">
            <summary>
                The gamepad left analog stick X axis. Value is position of the stick in the horizontal axis.
                Range <c>[-1, 1]</c>.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadLeftStickY">
            <summary>
                The gamepad left analog stick Y axis. Value is position of the stick in the vertical axis.
                Range <c>[-1, 1]</c>.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadRightStickUp">
            <summary>
                The derived right analog stick Y+ axis. Non-zero when stick moved up/away from the user.
                Range <c>[0, 1]</c>.
            </summary>
            <seealso cref="F:RavingBots.MultiInput.InputCode.PadRightStickY" />
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadRightStickDown">
            <summary>
                The derived right analog stick Y- axis. Non-zero when stick moved down/towards from the user.
                Range <c>[0, 1]</c>.
            </summary>
            <seealso cref="F:RavingBots.MultiInput.InputCode.PadRightStickY" />
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadRightStickLeft">
            <summary>
                The derived right analog stick X- axis. Non-zero when stick moved to the left.  Range <c>[0, 1]</c>.
            </summary>
            <seealso cref="F:RavingBots.MultiInput.InputCode.PadRightStickX" />
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadRightStickRight">
            <summary>
                The derived right analog stick X+ axis. Non-zero when stick moved to the right.  Range <c>[0, 1]</c>.
            </summary>
            <seealso cref="F:RavingBots.MultiInput.InputCode.PadRightStickX" />
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadRightStick">
            <summary>
                The gamepad right stick digital button.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadRightStickX">
            <summary>
                The gamepad right analog stick X axis. Value is position of the stick in the horizontal axis.
                Range <c>[-1, 1]</c>.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadRightStickY">
            <summary>
                The gamepad right analog stick Y axis. Value is position of the stick in the vertical axis.
                Range <c>[-1, 1]</c>.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadDPadUp">
            <summary>
                The gamepad up button (DPad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadDPadDown">
            <summary>
                The gamepad down button (DPad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadDPadLeft">
            <summary>
                The gamepad left button (DPad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadDPadRight">
            <summary>
                The gamepad right button (DPad).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadDPadX">
            <summary>
                The derived analog DPad X axis.
                Value is one of -1 (when <see cref="F:RavingBots.MultiInput.InputCode.PadDPadLeft" /> is pressed),
                1 (when <see cref="F:RavingBots.MultiInput.InputCode.PadDPadRight" /> is pressed) or 0 (when neither are pressed).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadDPadY">
            <summary>
                The derived analog DPad Y axis. Value is one of -1 (when <see cref="F:RavingBots.MultiInput.InputCode.PadDPadDown" /> is pressed),
                1 (when <see cref="F:RavingBots.MultiInput.InputCode.PadDPadUp" /> is pressed) or 0 (when neither are pressed).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadA">
            <summary>
                The gamepad A button (cross on PS4 gamepads).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadB">
            <summary>
                The gamepad B button (circle on PS4 gamepads).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadX">
            <summary>
                The gamepad X button (square on PS4 gamepads).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadY">
            <summary>
                The gamepad Y button (triangle on PS4 gamepads).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadLeftTrigger">
            <summary>
                The gamepad left trigger analog axis (L2 on PS4 gamepads). Range <c>[0, 1]</c>.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadRightTrigger">
            <summary>
                The gamepad right trigger analog axis (R2 on PS4 gamepads). Range <c>[0, 1]</c>.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadLeftBumper">
            <summary>
                The gamepad left bumper/shoulder digital button (L1 on PS4 gamepads).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadRightBumper">
            <summary>
                The gamepad right bumper/shoulder digital button (R1 on PS4 gamepads).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadBack">
            <summary>
                The gamepad Back (Xbox360), View (XboxOne), Select (PS3) or Share (PS4) digital button.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCode.PadStart">
            <summary>
                The gamepad Start (Xbox360/PS3), Menu (XboxOne) or Options (PS4) digital button.
            </summary>
        </member>
        <member name="T:RavingBots.MultiInput.InputCodeExt">
            <summary>
                Several utility methods and constants for <see cref="T:RavingBots.MultiInput.InputCode" />.
            </summary>
            <seealso cref="T:RavingBots.MultiInput.InputCode" />
            <threadsafety static="true" instance="true" />
        </member>
        <member name="F:RavingBots.MultiInput.InputCodeExt.KeyboardRangeStart">
            <summary>
                The start of the keyboard code range. The range extends to <see cref="F:RavingBots.MultiInput.InputCodeExt.KeyboardRangeEnd" /> (inclusive).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCodeExt.KeyboardRangeEnd">
            <summary>
                The end of the keyboard code range (inclusive).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCodeExt.KeyboardCustomRangeStart">
            <summary>
                The start of reserved subrange of keyboard codes. This is the first value you can use for your custom codes.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCodeExt.MouseRangeStart">
            <summary>
                The start of the mouse code range. The range extends to <see cref="F:RavingBots.MultiInput.InputCodeExt.MouseRangeEnd" /> (inclusive).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCodeExt.MouseRangeEnd">
            <summary>
                The end of the mouse code range (inclusive).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCodeExt.MouseCustomRangeStart">
            <summary>
                The start of reserved subrange of mouse codes. This is the first value you can use for your custom codes.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCodeExt.PadRangeStart">
            <summary>
                The start of the gamepad code range. The range extends to <see cref="F:RavingBots.MultiInput.InputCodeExt.PadRangeEnd" /> (inclusive).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCodeExt.PadRangeEnd">
            <summary>
                The end of the gamepad code range (inclusive).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputCodeExt.PadCustomRangeStart">
            <summary>
                The start of reserved subrange of gamepad codes. This is the first value you can use for your custom codes.
            </summary>
        </member>
        <member name="M:RavingBots.MultiInput.InputCodeExt.IsKeyboard(RavingBots.MultiInput.InputCode)">
            <summary>
                Returns <c>true</c> if given <see cref="T:RavingBots.MultiInput.InputCode" /> is a keyboard code.
            </summary>
            <param name="code">The code to check.</param>
            <returns>Whether the code is a keyboard code.</returns>
            <seealso cref="F:RavingBots.MultiInput.InputCodeExt.KeyboardRangeStart" />
            <seealso cref="F:RavingBots.MultiInput.InputCodeExt.KeyboardRangeEnd" />
        </member>
        <member name="M:RavingBots.MultiInput.InputCodeExt.IsMouse(RavingBots.MultiInput.InputCode)">
            <summary>
                Returns <c>true</c> if given <see cref="T:RavingBots.MultiInput.InputCode" /> is a mouse code.
            </summary>
            <param name="code">The code to check.</param>
            <returns>Whether the code is a mouse code.</returns>
            <seealso cref="F:RavingBots.MultiInput.InputCodeExt.MouseRangeStart" />
            <seealso cref="F:RavingBots.MultiInput.InputCodeExt.MouseRangeEnd" />
        </member>
        <member name="M:RavingBots.MultiInput.InputCodeExt.IsGamepad(RavingBots.MultiInput.InputCode)">
            <summary>
                Returns <c>true</c> if given <see cref="T:RavingBots.MultiInput.InputCode" /> is a gamepad code.
            </summary>
            <param name="code">The code to check.</param>
            <returns>Whether the code is a gamepad code.</returns>
            <seealso cref="F:RavingBots.MultiInput.InputCodeExt.PadRangeStart" />
            <seealso cref="F:RavingBots.MultiInput.InputCodeExt.PadRangeEnd" />
        </member>
        <member name="T:RavingBots.MultiInput.InputState">
            <summary>
                The main component of the library. You need to add this to every scene that
                uses components that query input. You should also give it priority over everything
                else in the script execution order settings.
            </summary>
            <remarks>
                <note type="important">
                    There should ever be only one alive instance of this component, and the instance must
                    outlive all active <see cref="T:RavingBots.MultiInput.IDevice" /> objects. Having multiple active instances is unsupported and might
                    cause issues. If you don't have special requirements you should leave <see cref="F:RavingBots.MultiInput.InputState.LifetimeManagement" /> set to
                    <c>true</c>.
                </note>
                <para>
                    This component initializes and controls the native code used to query the OS for state of devices
                    and their virtual axes. All of the currently detected devices can be found through the <see cref="P:RavingBots.MultiInput.InputState.Devices" />
                    property.
                    Additionally, you can subscribe to the <see cref="F:RavingBots.MultiInput.InputState.DeviceStateChanged" /> event to be notified when
                    a new device is plugged in, or an old device is unplugged.
                </para>
                <para>
                    <see cref="T:RavingBots.MultiInput.InputStateExt" /> class contains a set of convenience methods for querying a range of devices
                    on a range of axes.
                </para>
            </remarks>
            <threadsafety static="false" instance="false" />
            <seealso cref="T:RavingBots.MultiInput.InputStateExt" />
        </member>
        <member name="F:RavingBots.MultiInput.InputState.LogLevel">
            <summary>
                Preferred log level.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputState.UseFixedUpdate">
            <summary>
                Switches to using FixedUpdate to drain events and poll for updates.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputState.LifetimeManagement">
            <summary>
                Toggles lifetime management. If <c>true</c>, <c>DontDestroyOnLoad</c> will be called on
                GameObject containing this component and extraneous instances will be automatically
                destroyed. <c>InputState</c> must strictly outlive all device objects, so this is
                necessary if you want <see cref="T:RavingBots.MultiInput.IDevice" /> objects to be usable after scene changes.
            </summary>
        </member>
        <member name="P:RavingBots.MultiInput.InputState.Devices">
            <summary>
                The list of currently active devices. Subscribe to the <see cref="F:RavingBots.MultiInput.InputState.DeviceStateChanged" /> event
                to be notified when this list changes.
            </summary>
            <value>
                An <see cref="T:System.Collections.Generic.IEnumerable`1"></see> of all known devices.
                It's not backed by a collection: you need to drain the elements with <see cref="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" /> or
                similar
                if you want to iterate over it more than once.
            </value>
            <seealso cref="F:RavingBots.MultiInput.InputState.DeviceStateChanged" />
            <seealso cref="T:RavingBots.MultiInput.IDevice" />
        </member>
        <member name="F:RavingBots.MultiInput.InputState.DeviceStateChanged">
            <summary>
                Event fired when the <see cref="P:RavingBots.MultiInput.InputState.Devices" /> list changes.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputState.DevicesEnumerated">
            <summary>
                Event fired after the <see cref="P:RavingBots.MultiInput.InputState.Devices" /> list is first populated.
                Will only be fired once during the component lifetime (use <see cref="F:RavingBots.MultiInput.InputState.DeviceStateChanged" />
                event to get updates).
            </summary>
        </member>
        <member name="M:RavingBots.MultiInput.InputState.Reset">
            <summary>
                Resets the state of all axes on all devices.
            </summary>
            <remarks>
                This method works by committing a zero value on every supported axis
                on every known device.
            </remarks>
        </member>
        <member name="M:RavingBots.MultiInput.InputState.FindFirst(RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean},System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})">
            <summary>
                Overload of
                <see
                    cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean})" />
                that limits the search to selected axes, given as <see cref="T:System.Collections.Generic.IEnumerable`1" /> argument.
                Use this form if you have a collection of input codes.
            </summary>
            <example>
                The following example shows how you can use this method to find first
                <see cref="F:RavingBots.MultiInput.InputCode.PadLeftTrigger" /> or <see cref="F:RavingBots.MultiInput.InputCode.PadRightTrigger" /> axis that
                reports a value of at least 0.5.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            var axes = new List&lt;InputCode&gt; {
                InputCode.PadLeftTrigger,
                InputCode.PadRightTrigger
            };
            IDevice device;
            VirtualAxis axis;
            if (state.FindFirst(out device, out axis, v => v.Value >= 0.5f, axes)) {
                Debug.LogFormat("Found Value >= 0.5 on device {0}, axis {1}", device.Name, axis.Code);
            } else {
                Debug.LogFormat("Value >= 0.5 not found");
            }
            </code>
            </example>
            <param name="foundDevice">
                If this method returned <c>true</c>, set to the found device. Otherwise,
                set to <c>null</c>.
            </param>
            <param name="foundAxis">
                If this method returned <c>true</c>, set to the found axis. Otherwise,
                set to <c>null</c>. You can check the axis code via <see cref="P:RavingBots.MultiInput.IVirtualAxis.Code" /> property.
            </param>
            <param name="predicate">
                Predicate for the search. Takes a <see cref="T:RavingBots.MultiInput.IDevice" /> object, an instance of <see cref="T:RavingBots.MultiInput.IVirtualAxis" />
                that belongs to that device, and should return <c>true</c> if said axis reports a value that interests you.
            </param>
            <param name="axes">Axes to search through.</param>
            <returns>
                <c>true</c> if predicate returned <c>true</c> for at least one axis, <c>false</c> otherwise.
            </returns>
            <seealso
                cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean})" />
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirstDown(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})" />
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirstUp(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})" />
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirstHeld(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})" />
        </member>
        <member name="T:RavingBots.MultiInput.InputStateExt">
            <summary>
                Various convenience extension methods for <see cref="T:RavingBots.MultiInput.InputState" />.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.InputStateExt.AllAxes">
            <summary>
                Collection containing all values from <see cref="T:RavingBots.MultiInput.InputCode" /> enumeration, provided for convenience.
            </summary>
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean})">
            <summary>
                Queries all axes on all devices, and returns first for which a given predicate
                returns <c>true</c>. If you don't require a custom predicate (i.e. you just want to check
                <see cref="P:RavingBots.MultiInput.IVirtualAxis.IsHeld" /> or similar), you should use simpler variants like
                <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirstHeld(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" />.
            </summary>
            <example>
                The following example shows how you can use this method to find first input axis that reports
                a value of at least 0.5.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            IDevice device;
            IVirtualAxis axis;
            if (state.FindFirst(out device, out axis, a => a.Value >= 0.5f)) {
                Debug.LogFormat("Found Value >= 0.5 on device {0}, axis {1}", device.Name, axis.Code);
            } else {
                Debug.LogFormat("Value >= 0.5 not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="foundDevice">
                If this method returned <c>true</c>, set to the found device. Otherwise,
                set to <c>null</c>.
            </param>
            <param name="foundAxis">
                If this method returned <c>true</c>, set to the found axis. Otherwise,
                set to <c>null</c>. You can check the axis code via <see cref="P:RavingBots.MultiInput.IVirtualAxis.Code" /> property.
            </param>
            <param name="predicate">
                Predicate for the search. Takes a <see cref="T:RavingBots.MultiInput.IDevice" /> object, an instance of <see cref="T:RavingBots.MultiInput.IVirtualAxis" />
                that belongs to that device, and should return <c>true</c> if said axis reports a value that interests you.
            </param>
            <returns>
                <c>true</c> if predicate returned <c>true</c> for at least one axis, <c>false</c> otherwise.
            </returns>
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirstDown(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" />
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirstUp(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" />
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirstHeld(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean},RavingBots.MultiInput.InputCode[])">
            <summary>
                Overload of
                <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean})" /> that
                limits
                the search to selected axes, given as <c>params</c> argument. Use this form if you're specifying input codes
                manually.
            </summary>
            <example>
                The following example shows how you can use this method to find first
                <see cref="F:RavingBots.MultiInput.InputCode.PadLeftTrigger" /> or <see cref="F:RavingBots.MultiInput.InputCode.PadRightTrigger" /> axis that
                reports a value of at least 0.5.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            IDevice device;
            IVirtualAxis axis;
            if (state.FindFirst(out device, out axis, v => v.Value >= 0.5f, InputCode.PadLeftTrigger, InputCode.PadRightTrigger)) {
                Debug.LogFormat("Found Value >= 0.5 on device {0}, axis {1}", device.Name, axis.Code);
            } else {
                Debug.LogFormat("Value >= 0.5 not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="foundDevice">
                If this method returned <c>true</c>, set to the found device. Otherwise,
                set to <c>null</c>.
            </param>
            <param name="foundAxis">
                If this method returned <c>true</c>, set to the found axis. Otherwise,
                set to <c>null</c>. You can check the axis code via <see cref="P:RavingBots.MultiInput.IVirtualAxis.Code" /> property.
            </param>
            <param name="predicate">
                Predicate for the search. Takes a <see cref="T:RavingBots.MultiInput.IDevice" /> object, an instance of <see cref="T:RavingBots.MultiInput.IVirtualAxis" />
                that belongs to that device, and should return <c>true</c> if said axis reports a value that interests you.
            </param>
            <param name="axes">Axes to search through.</param>
            <returns>
                <c>true</c> if predicate returned <c>true</c> for at least one axis, <c>false</c> otherwise.
            </returns>
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean})" />
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirstDown(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,RavingBots.MultiInput.InputCode[])" />
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirstUp(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,RavingBots.MultiInput.InputCode[])" />
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirstHeld(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,RavingBots.MultiInput.InputCode[])" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean})">
            <summary>
                Overload of
                <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean})" /> that
                only returns the device. Use this form if you only need the device object.
            </summary>
            <example>
                The following example shows how you can use this method to find first device that reports
                a value of at least 0.5 on any axis.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            var device = state.FindFirst(a => a.Value >= 0.5f);
            if (device != null) {
                Debug.LogFormat("Found Value >= 0.5 on device {0}", device.Name);
            } else {
                Debug.LogFormat("Value >= 0.5 not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="predicate">
                Predicate for the search. Takes a <see cref="T:RavingBots.MultiInput.IDevice" /> object, an instance of <see cref="T:RavingBots.MultiInput.IVirtualAxis" />
                that belongs to that device, and should return <c>true</c> if said axis reports a value that interests you.
            </param>
            <returns>Found device, or <c>null</c> if none were found.</returns>
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean})" />
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirstDown(RavingBots.MultiInput.InputState)" />
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirstUp(RavingBots.MultiInput.InputState)" />
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirstHeld(RavingBots.MultiInput.InputState)" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean},RavingBots.MultiInput.InputCode[])">
            <summary>
                Overload of
                <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean})" /> that
                only returns the device and limits the search to selected axes, given as <c>params</c> argument.
                Use this form if you only need the device object and you're specifying input codes manually.
            </summary>
            <example>
                The following example shows how you can use this method to find first device that reports
                a value of at least 0.5 on <see cref="F:RavingBots.MultiInput.InputCode.PadLeftTrigger" /> or <see cref="F:RavingBots.MultiInput.InputCode.PadRightTrigger" />
                axes.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            var device = state.FindFirst(a => a.Value >= 0.5f, InputCode.PadLeftTrigger, InputCode.PadRightTrigger);
            if (device != null) {
                Debug.LogFormat("Found Value >= 0.5 on device {0}", device.Name);
            } else {
                Debug.LogFormat("Value >= 0.5 not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="predicate">
                Predicate for the search. Takes a <see cref="T:RavingBots.MultiInput.IDevice" /> object, an instance of <see cref="T:RavingBots.MultiInput.IVirtualAxis" />
                that belongs to that device, and should return <c>true</c> if said axis reports a value that interests you.
            </param>
            <param name="axes">Axes to search through.</param>
            <returns>Found device, or <c>null</c> if none were found.</returns>
            <seealso
                cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean},RavingBots.MultiInput.InputCode[])" />
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirstDown(RavingBots.MultiInput.InputState,RavingBots.MultiInput.InputCode[])" />
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirstUp(RavingBots.MultiInput.InputState,RavingBots.MultiInput.InputCode[])" />
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirstHeld(RavingBots.MultiInput.InputState,RavingBots.MultiInput.InputCode[])" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean},System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})">
            <summary>
                Overload of
                <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean})" /> that
                only returns the device and limits
                the search to selected axes, given as <see cref="T:System.Collections.Generic.IEnumerable`1" /> argument.
                Use this form if you only need the device object and you have a collection of input codes.
            </summary>
            <example>
                The following example shows how you can use this method to find first device that reports
                a value of at least 0.5 on <see cref="F:RavingBots.MultiInput.InputCode.PadLeftTrigger" /> or <see cref="F:RavingBots.MultiInput.InputCode.PadRightTrigger" />
                axes.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            var axes = new List&lt;InputCode&gt; {
                InputCode.PadLeftTrigger,
                InputCode.PadRightTrigger
            };
            var device = state.FindFirst(a => a.Value >= 0.5f, axes);
            if (device != null) {
                Debug.LogFormat("Found Value >= 0.5 on device {0}", device.Name);
            } else {
                Debug.LogFormat("Value >= 0.5 not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="predicate">
                Predicate for the search. Takes a <see cref="T:RavingBots.MultiInput.IDevice" /> object, an instance of <see cref="T:RavingBots.MultiInput.IVirtualAxis" />
                that belongs to that device, and should return <c>true</c> if said axis reports a value that interests you.
            </param>
            <param name="axes">Axes to search through.</param>
            <returns>Found device, or <c>null</c> if none were found.</returns>
            <seealso
                cref="M:RavingBots.MultiInput.InputState.FindFirst(RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean},System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})" />
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirstDown(RavingBots.MultiInput.InputState,System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})" />
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirstUp(RavingBots.MultiInput.InputState,System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})" />
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirstHeld(RavingBots.MultiInput.InputState,System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirstHeld(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)">
            <summary>
                Queries all axes on all devices, and returns the first for which <see cref="P:RavingBots.MultiInput.IVirtualAxis.IsHeld" />
                is <c>true</c>.
            </summary>
            <example>
                The following example shows how you can use this method to find first input axis that
                reports non-zero value.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            IDevice device;
            IVirtualAxis axis;
            if (state.FindFirstHeld(out device, out axis)) {
                Debug.LogFormat("Found non-zero value on device {0}, axis {1}", device.Name, axis.Code);
            } else {
                Debug.LogFormat("Non-zero value not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="foundDevice">
                If this method returned <c>true</c>, set to the found device. Otherwise,
                set to <c>null</c>.
            </param>
            <param name="foundAxis">
                If this method returned <c>true</c>, set to the found axis. Otherwise,
                set to <c>null</c>. You can check the axis code via <see cref="P:RavingBots.MultiInput.IVirtualAxis.Code" /> property.
            </param>
            <returns>
                <c>true</c> if <see cref="P:RavingBots.MultiInput.IVirtualAxis.IsHeld" /> was <c>true</c> for at least one axis, <c>false</c> otherwise.
            </returns>
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean})" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirstHeld(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,RavingBots.MultiInput.InputCode[])">
            <summary>
                Overload of <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirstHeld(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" /> that limits
                the search to selected axes, given as <c>params</c> argument. Use this form if you're specifying input codes
                manually.
            </summary>
            <example>
                The following example shows how you can use this method to find first held
                <see cref="F:RavingBots.MultiInput.InputCode.PadLeftTrigger" /> or <see cref="F:RavingBots.MultiInput.InputCode.PadRightTrigger" /> axis.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            IDevice device;
            IVirtualAxis axis;
            if (state.FindFirstHeld(out device, out axis, InputCode.PadLeftTrigger, InputCode.PadRightTrigger)) {
                Debug.LogFormat("Found held trigger on device {0}, axis {1}", device.Name, axis.Code);
            } else {
                Debug.LogFormat("Held trigger not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="foundDevice">
                If this method returned <c>true</c>, set to the found device. Otherwise,
                set to <c>null</c>.
            </param>
            <param name="foundAxis">
                If this method returned <c>true</c>, set to the found axis. Otherwise,
                set to <c>null</c>. You can check the axis code via <see cref="P:RavingBots.MultiInput.IVirtualAxis.Code" /> property.
            </param>
            <param name="axes">Axes to search through.</param>
            <returns>
                <c>true</c> if <see cref="P:RavingBots.MultiInput.IVirtualAxis.IsHeld" /> was <c>true</c> for at least one axis, <c>false</c> otherwise.
            </returns>
            <seealso
                cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean},RavingBots.MultiInput.InputCode[])" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirstHeld(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})">
            <summary>
                Overload of <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirstHeld(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" /> that limits
                the search to selected axes, given as <see cref="T:System.Collections.Generic.IEnumerable`1" /> argument.
                Use this form if you have a collection of input codes.
            </summary>
            <example>
                The following example shows how you can use this method to find first held
                <see cref="F:RavingBots.MultiInput.InputCode.PadLeftTrigger" /> or <see cref="F:RavingBots.MultiInput.InputCode.PadRightTrigger" /> axis.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            var axes = new List&lt;InputCode&gt; {
                InputCode.PadLeftTrigger,
                InputCode.PadRightTrigger
            };
            IDevice device;
            IVirtualAxis axis;
            if (state.FindFirstHeld(out device, out axis, axes)) {
                Debug.LogFormat("Found held trigger on device {0}, axis {1}", device.Name, axis.Code);
            } else {
                Debug.LogFormat("Held trigger not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="foundDevice">
                If this method returned <c>true</c>, set to the found device. Otherwise,
                set to <c>null</c>.
            </param>
            <param name="foundAxis">
                If this method returned <c>true</c>, set to the found axis. Otherwise,
                set to <c>null</c>. You can check the axis code via <see cref="P:RavingBots.MultiInput.IVirtualAxis.Code" /> property.
            </param>
            <param name="axes">Axes to search through.</param>
            <returns>
                <c>true</c> if <see cref="P:RavingBots.MultiInput.IVirtualAxis.IsHeld" /> was <c>true</c> for at least one axis, <c>false</c> otherwise.
            </returns>
            <seealso
                cref="M:RavingBots.MultiInput.InputState.FindFirst(RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean},System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirstHeld(RavingBots.MultiInput.InputState)">
            <summary>
                Overload of <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirstHeld(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" /> that
                only returns the device. Use this form if you only need the device object.
            </summary>
            <example>
                The following example shows how you can use this method to find first input axis that
                reports non-zero value.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            var device = state.FindFirstHeld();
            if (device != null) {
                Debug.LogFormat("Found non-zero axis on device {0}", device.Name);
            } else {
                Debug.LogFormat("Non-zero axis not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <returns>Found device, or <c>null</c>.</returns>
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean})" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirstHeld(RavingBots.MultiInput.InputState,RavingBots.MultiInput.InputCode[])">
            <summary>
                Overload of <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirstHeld(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" /> that
                only returns the device and limits the search to selected axes, given as <c>params</c> argument.
                Use this form if you only need the device object and you're specifying input codes manually.
            </summary>
            <example>
                The following example shows how you can use this method to find first held
                <see cref="F:RavingBots.MultiInput.InputCode.PadLeftTrigger" /> or <see cref="F:RavingBots.MultiInput.InputCode.PadRightTrigger" /> axis.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            var device = state.FindFirstHeld(InputCode.PadLeftTrigger, InputCode.PadRightTrigger);
            if (device != null) {
                Debug.LogFormat("Found held trigger on device {0}", device.Name);
            } else {
                Debug.LogFormat("Held trigger not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="axes">Axes to search through.</param>
            <returns>Found device, or <c>null</c>.</returns>
            <seealso
                cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean},RavingBots.MultiInput.InputCode[])" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirstHeld(RavingBots.MultiInput.InputState,System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})">
            <summary>
                Overload of <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirstHeld(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" /> that
                only returns the device and limits
                the search to selected axes, given as <see cref="T:System.Collections.Generic.IEnumerable`1" /> argument.
                Use this form if you only need the device object and you have a collection of input codes.
            </summary>
            <example>
                The following example shows how you can use this method to find first held
                <see cref="F:RavingBots.MultiInput.InputCode.PadLeftTrigger" /> or <see cref="F:RavingBots.MultiInput.InputCode.PadRightTrigger" /> axis.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            var axes = new List&lt;InputCode&gt; {
                InputCode.PadLeftTrigger,
                InputCode.PadRightTrigger
            };
            var device = state.FindFirstHeld(axes);
            if (device != null) {
                Debug.LogFormat("Found held trigger on device {0}", device.Name);
            } else {
                Debug.LogFormat("Held trigger not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="axes">Axes to search through.</param>
            <returns>Found device, or <c>null</c>.</returns>
            <seealso
                cref="M:RavingBots.MultiInput.InputState.FindFirst(RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean},System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirstUp(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)">
            <summary>
                Queries all axes on all devices, and returns the first for which <see cref="P:RavingBots.MultiInput.IVirtualAxis.IsUp" />
                is <c>true</c>.
            </summary>
            <example>
                The following example shows how you can use this method to find first input axis that
                became non-zero in this frame.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            IDevice device;
            IVirtualAxis axis;
            if (state.FindFirstUp(out device, out axis)) {
                Debug.LogFormat("Found IsUp on device {0}, axis {1}", device.Name, axis.Code);
            } else {
                Debug.LogFormat("IsUp not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="foundDevice">
                If this method returned <c>true</c>, set to the found device. Otherwise,
                set to <c>null</c>.
            </param>
            <param name="foundAxis">
                If this method returned <c>true</c>, set to the found axis. Otherwise,
                set to <c>null</c>. You can check the axis code via <see cref="P:RavingBots.MultiInput.IVirtualAxis.Code" /> property.
            </param>
            <returns>
                <c>true</c> if <see cref="P:RavingBots.MultiInput.IVirtualAxis.IsUp" /> was <c>true</c> for at least one axis, <c>false</c> otherwise.
            </returns>
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean})" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirstUp(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,RavingBots.MultiInput.InputCode[])">
            <summary>
                Overload of <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirstUp(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" /> that limits
                the search to selected axes, given as <c>params</c> argument. Use this form if you're specifying input codes
                manually.
            </summary>
            <example>
                The following example shows how you can use this method to find first
                <see cref="F:RavingBots.MultiInput.InputCode.PadLeftTrigger" /> or <see cref="F:RavingBots.MultiInput.InputCode.PadRightTrigger" /> axis
                that became non-zero in this frame.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            IDevice device;
            IVirtualAxis axis;
            if (state.FindFirstUp(out device, out axis, InputCode.PadLeftTrigger, InputCode.PadRightTrigger)) {
                Debug.LogFormat("Found IsUp trigger on device {0}, axis {1}", device.Name, axis.Code);
            } else {
                Debug.LogFormat("IsUp trigger not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="foundDevice">
                If this method returned <c>true</c>, set to the found device. Otherwise,
                set to <c>null</c>.
            </param>
            <param name="foundAxis">
                If this method returned <c>true</c>, set to the found axis. Otherwise,
                set to <c>null</c>. You can check the axis code via <see cref="P:RavingBots.MultiInput.IVirtualAxis.Code" /> property.
            </param>
            <param name="axes">Axes to search through.</param>
            <returns>
                <c>true</c> if <see cref="P:RavingBots.MultiInput.IVirtualAxis.IsUp" /> was <c>true</c> for at least one axis, <c>false</c> otherwise.
            </returns>
            <seealso
                cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean},RavingBots.MultiInput.InputCode[])" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirstUp(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})">
            <summary>
                Overload of <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirstUp(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" /> that limits
                the search to selected axes, given as <see cref="T:System.Collections.Generic.IEnumerable`1" /> argument.
                Use this form if you have a collection of input codes.
            </summary>
            <example>
                The following example shows how you can use this method to find first up
                <see cref="F:RavingBots.MultiInput.InputCode.PadLeftTrigger" /> or <see cref="F:RavingBots.MultiInput.InputCode.PadRightTrigger" /> axis
                that became non-zero in this frame.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            var axes = new List&lt;InputCode&gt; {
                InputCode.PadLeftTrigger,
                InputCode.PadRightTrigger
            };
            IDevice device;
            IVirtualAxis axis;
            if (state.FindFirstUp(out device, out axis, axes)) {
                Debug.LogFormat("Found IsUp trigger on device {0}, axis {1}", device.Name, axis.Code);
            } else {
                Debug.LogFormat("IsUp trigger not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="foundDevice">
                If this method returned <c>true</c>, set to the found device. Otherwise,
                set to <c>null</c>.
            </param>
            <param name="foundAxis">
                If this method returned <c>true</c>, set to the found axis. Otherwise,
                set to <c>null</c>. You can check the axis code via <see cref="P:RavingBots.MultiInput.IVirtualAxis.Code" /> property.
            </param>
            <param name="axes">Axes to search through.</param>
            <returns>
                <c>true</c> if <see cref="P:RavingBots.MultiInput.IVirtualAxis.IsUp" /> was <c>true</c> for at least one axis, <c>false</c> otherwise.
            </returns>
            <seealso
                cref="M:RavingBots.MultiInput.InputState.FindFirst(RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean},System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirstUp(RavingBots.MultiInput.InputState)">
            <summary>
                Overload of <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirstUp(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" /> that
                only returns the device. Use this form if you only need the device object.
            </summary>
            <example>
                The following example shows how you can use this method to find first input axis
                that became non-zero in this frame.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            var device = state.FindFirstUp();
            if (device != null) {
                Debug.LogFormat("Found IsUp on device {0}", device.Name);
            } else {
                Debug.LogFormat("IsUp not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <returns>Found device, or <c>null</c>.</returns>
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean})" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirstUp(RavingBots.MultiInput.InputState,RavingBots.MultiInput.InputCode[])">
            <summary>
                Overload of <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirstUp(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" /> that
                only returns the device and limits the search to selected axes, given as <c>params</c> argument.
                Use this form if you only need the device object and you're specifying input codes manually.
            </summary>
            <example>
                The following example shows how you can use this method to find first up
                <see cref="F:RavingBots.MultiInput.InputCode.PadLeftTrigger" /> or <see cref="F:RavingBots.MultiInput.InputCode.PadRightTrigger" /> axis
                that became non-zero in this frame.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            var device = state.FindFirstUp(InputCode.PadLeftTrigger, InputCode.PadRightTrigger);
            if (device != null) {
                Debug.LogFormat("Found IsUp trigger on device {0}", device.Name);
            } else {
                Debug.LogFormat("IsUp trigger not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="axes">Axes to search through.</param>
            <returns>Found device, or <c>null</c>.</returns>
            <seealso
                cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean},RavingBots.MultiInput.InputCode[])" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirstUp(RavingBots.MultiInput.InputState,System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})">
            <summary>
                Overload of <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirstUp(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" /> that
                only returns the device and limits
                the search to selected axes, given as <see cref="T:System.Collections.Generic.IEnumerable`1" /> argument.
                Use this form if you only need the device object and you have a collection of input codes.
            </summary>
            <example>
                The following example shows how you can use this method to find first
                <see cref="F:RavingBots.MultiInput.InputCode.PadLeftTrigger" /> or <see cref="F:RavingBots.MultiInput.InputCode.PadRightTrigger" /> axis
                that became non-zero in this frame.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            var axes = new List&lt;InputCode&gt; {
                InputCode.PadLeftTrigger,
                InputCode.PadRightTrigger
            };
            var device = state.FindFirstUp(axes);
            if (device != null) {
                Debug.LogFormat("Found IsUp trigger on device {0}", device.Name);
            } else {
                Debug.LogFormat("IsUp trigger not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="axes">Axes to search through.</param>
            <returns>Found device, or <c>null</c>.</returns>
            <seealso
                cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean},RavingBots.MultiInput.InputCode[])" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirstDown(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)">
            <summary>
                Queries all axes on all devices, and returns the first for which <see cref="P:RavingBots.MultiInput.IVirtualAxis.IsDown" />
                is <c>true</c>.
            </summary>
            <example>
                The following example shows how you can use this method to find first input axis
                that became zero in this frame.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            IDevice device;
            IVirtualAxis axis;
            if (state.FindFirstDown(out device, out axis)) {
                Debug.LogFormat("Found IsDown on device {0}, axis {1}", device.Name, axis.Code);
            } else {
                Debug.LogFormat("IsDown not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="foundDevice">
                If this method returned <c>true</c>, set to the found device. Otherwise,
                set to <c>null</c>.
            </param>
            <param name="foundAxis">
                If this method returned <c>true</c>, set to the found axis. Otherwise,
                set to <c>null</c>. You can check the axis code via <see cref="P:RavingBots.MultiInput.IVirtualAxis.Code" /> property.
            </param>
            <returns>
                <c>true</c> if <see cref="P:RavingBots.MultiInput.IVirtualAxis.IsDown" /> was <c>true</c> for at least one axis, <c>false</c> otherwise.
            </returns>
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean})" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirstDown(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,RavingBots.MultiInput.InputCode[])">
            <summary>
                Overload of <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirstDown(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" /> that limits
                the search to selected axes, given as <c>params</c> argument. Use this form if you're specifying input codes
                manually.
            </summary>
            <example>
                The following example shows how you can use this method to find first
                <see cref="F:RavingBots.MultiInput.InputCode.PadLeftTrigger" /> or <see cref="F:RavingBots.MultiInput.InputCode.PadRightTrigger" /> axis
                that became zero in this frame.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            IDevice device;
            IVirtualAxis axis;
            if (state.FindFirstDown(out device, out axis, InputCode.PadLeftTrigger, InputCode.PadRightTrigger)) {
                Debug.LogFormat("Found IsDown trigger on device {0}, axis {1}", device.Name, axis.Code);
            } else {
                Debug.LogFormat("IsDown trigger not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="foundDevice">
                If this method returned <c>true</c>, set to the found device. Otherwise,
                set to <c>null</c>.
            </param>
            <param name="foundAxis">
                If this method returned <c>true</c>, set to the found axis. Otherwise,
                set to <c>null</c>. You can check the axis code via <see cref="P:RavingBots.MultiInput.IVirtualAxis.Code" /> property.
            </param>
            <param name="axes">Axes to search through.</param>
            <returns>
                <c>true</c> if <see cref="P:RavingBots.MultiInput.IVirtualAxis.IsDown" /> was <c>true</c> for at least one axis, <c>false</c> otherwise.
            </returns>
            <seealso
                cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean},RavingBots.MultiInput.InputCode[])" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirstDown(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})">
            <summary>
                Overload of <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirstDown(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" /> that limits
                the search to selected axes, given as <see cref="T:System.Collections.Generic.IEnumerable`1" /> argument.
                Use this form if you have a collection of input codes.
            </summary>
            <example>
                The following example shows how you can use this method to find first
                <see cref="F:RavingBots.MultiInput.InputCode.PadLeftTrigger" /> or <see cref="F:RavingBots.MultiInput.InputCode.PadRightTrigger" /> axis
                that became zero in this frame.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            var axes = new List&lt;InputCode&gt; {
                InputCode.PadLeftTrigger,
                InputCode.PadRightTrigger
            };
            IDevice device;
            IVirtualAxis axis;
            if (state.FindFirstDown(out device, out axis, axes)) {
                Debug.LogFormat("Found IsDown trigger on device {0}, axis {1}", device.Name, axis.Code);
            } else {
                Debug.LogFormat("IsDown trigger not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="foundDevice">
                If this method returned <c>true</c>, set to the found device. Otherwise,
                set to <c>null</c>.
            </param>
            <param name="foundAxis">
                If this method returned <c>true</c>, set to the found axis. Otherwise,
                set to <c>null</c>. You can check the axis code via <see cref="P:RavingBots.MultiInput.IVirtualAxis.Code" /> property.
            </param>
            <param name="axes">Axes to search through.</param>
            <returns>
                <c>true</c> if <see cref="P:RavingBots.MultiInput.IVirtualAxis.IsDown" /> was <c>true</c> for at least one axis, <c>false</c> otherwise.
            </returns>
            <seealso
                cref="M:RavingBots.MultiInput.InputState.FindFirst(RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean},System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirstDown(RavingBots.MultiInput.InputState)">
            <summary>
                Overload of <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirstDown(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" /> that
                only returns the device. Use this form if you only need the device object.
            </summary>
            <example>
                The following example shows how you can use this method to find first input axis
                that became zero in this frame.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            var device = state.FindFirstDown();
            if (device != null) {
                Debug.LogFormat("Found IsDown on device {0}", device.Name);
            } else {
                Debug.LogFormat("IsDown not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <returns>Found device, or <c>null</c>.</returns>
            <seealso cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean})" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirstDown(RavingBots.MultiInput.InputState,RavingBots.MultiInput.InputCode[])">
            <summary>
                Overload of <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirstDown(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" /> that
                only returns the device and limits the search to selected axes, given as <c>params</c> argument.
                Use this form if you only need the device object and you're specifying input codes manually.
            </summary>
            <example>
                The following example shows how you can use this method to find first
                <see cref="F:RavingBots.MultiInput.InputCode.PadLeftTrigger" /> or <see cref="F:RavingBots.MultiInput.InputCode.PadRightTrigger" /> axis
                that became zero in this frame.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            var device = state.FindFirstDown(InputCode.PadLeftTrigger, InputCode.PadRightTrigger);
            if (device != null) {
                Debug.LogFormat("Found IsDown trigger on device {0}", device.Name);
            } else {
                Debug.LogFormat("IsDown trigger not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="axes">Axes to search through.</param>
            <returns>Found device, or <c>null</c>.</returns>
            <seealso
                cref="M:RavingBots.MultiInput.InputStateExt.FindFirst(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean},RavingBots.MultiInput.InputCode[])" />
        </member>
        <member name="M:RavingBots.MultiInput.InputStateExt.FindFirstDown(RavingBots.MultiInput.InputState,System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})">
            <summary>
                Overload of <see cref="M:RavingBots.MultiInput.InputStateExt.FindFirstDown(RavingBots.MultiInput.InputState,RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@)" /> that
                only returns the device and limits
                the search to selected axes, given as <see cref="T:System.Collections.Generic.IEnumerable`1" /> argument.
                Use this form if you only need the device object and you have a collection of input codes.
            </summary>
            <example>
                The following example shows how you can use this method to find first
                <see cref="F:RavingBots.MultiInput.InputCode.PadLeftTrigger" /> or <see cref="F:RavingBots.MultiInput.InputCode.PadRightTrigger" /> axis
                that became zero in this frame.
                <code>
            var state = FindObjectOfType&lt;InputState&gt;();
            var axes = new List&lt;InputCode&gt; {
                InputCode.PadLeftTrigger,
                InputCode.PadRightTrigger
            };
            var device = state.FindFirstDown(axes);
            if (device != null) {
                Debug.LogFormat("Found IsDown trigger on device {0}", device.Name);
            } else {
                Debug.LogFormat("IsDown trigger not found");
            }
            </code>
            </example>
            <param name="state"><see cref="T:RavingBots.MultiInput.InputState" /> instance.</param>
            <param name="axes">Axes to search through.</param>
            <returns>Found device, or <c>null</c>.</returns>
            <seealso
                cref="M:RavingBots.MultiInput.InputState.FindFirst(RavingBots.MultiInput.IDevice@,RavingBots.MultiInput.IVirtualAxis@,System.Func{RavingBots.MultiInput.IDevice,RavingBots.MultiInput.IVirtualAxis,System.Boolean},System.Collections.Generic.IEnumerable{RavingBots.MultiInput.InputCode})" />
        </member>
        <member name="T:RavingBots.MultiInput.IVirtualAxis">
            <summary>
                Scalar values representing a virtual axis in previous, current and
                next frame.
            </summary>
            <remarks>
                <para>
                    This interface is one of the two core abstractions in Multi-Input (the other one
                    being <see cref="T:RavingBots.MultiInput.IDevice" />). All of your input queries will return objects that
                    implement <c>IVirtualAxis</c>.
                </para>
                <para>
                    Virtual axes track their value in a sliding window of previous, current and next frame.
                    Value of the next frame is fetched from platform-specific sources and then <see cref="M:RavingBots.MultiInput.IVirtualAxis.Commit">committed</see>
                    at
                    the beginning of the frame. Committing replaces previous value with current value, and current value with next
                    value.
                </para>
                <para>
                    All supported inputs (be it digital buttons, analog axes, or completely virtual axes that have no direct
                    physical
                    equivalent) are represented as a scalar floating point value. The exact range depends on the axis in question
                    (for example, buttons will only report discrete 0 or 1, while analog axes will report contiguous values in
                    various
                    ranges, e.g. <c>[0, 1]</c> or <c>[-1, 1]</c>).
                </para>
                <note type="important">
                    You can (and likely will) create your own virtual axes that aren't attached to any devices (see
                    <see cref="T:RavingBots.MultiInput.VirtualAxis" />).
                    Remember to <see cref="M:RavingBots.MultiInput.IVirtualAxis.Commit" /> all the values you <see cref="M:RavingBots.MultiInput.IVirtualAxis.Set(System.Single)" /> on these axes.
                </note>
            </remarks>
            <seealso cref="T:RavingBots.MultiInput.VirtualAxis" />
            <threadsafety static="false" instance="false" />
        </member>
        <member name="P:RavingBots.MultiInput.IVirtualAxis.IsUp">
            <summary>
                <c>true</c> if <see cref="P:RavingBots.MultiInput.IVirtualAxis.IsHeld" /> was <c>true</c> in the previous frame
                and isn't in this one.
            </summary>
            <value>If <c>true</c>, this axis has returned to the rest state in the current frame.</value>
        </member>
        <member name="P:RavingBots.MultiInput.IVirtualAxis.IsDown">
            <summary>
                <c>true</c> if <see cref="P:RavingBots.MultiInput.IVirtualAxis.IsHeld" /> was <c>false</c> in the previous frame
                but isn't in this one.
            </summary>
            <value>If <c>true</c>, this axis has left rest state in the current frame.</value>
        </member>
        <member name="P:RavingBots.MultiInput.IVirtualAxis.IsHeld">
            <summary>
                <c>true</c> if this axis is not in the rest state in the current frame
                (i.e. <see cref="P:RavingBots.MultiInput.IVirtualAxis.Value" /> is not zero).
            </summary>
        </member>
        <member name="P:RavingBots.MultiInput.IVirtualAxis.HasChanged">
            <summary>
                <c>true</c> if value on this axis has changed from the previous frame.
            </summary>
        </member>
        <member name="P:RavingBots.MultiInput.IVirtualAxis.Value">
            <summary>
                Value on this axis in the current frame.
            </summary>
        </member>
        <member name="P:RavingBots.MultiInput.IVirtualAxis.PreviousValue">
            <summary>
                Value on this axis in the previous frame.
            </summary>
        </member>
        <member name="P:RavingBots.MultiInput.IVirtualAxis.NextValue">
            <summary>
                Uncommitted value on this axis for the next frame. May change multiple times
                during a single frame until <see cref="M:RavingBots.MultiInput.IVirtualAxis.Commit">committed</see>.
            </summary>
        </member>
        <member name="P:RavingBots.MultiInput.IVirtualAxis.Code">
            <summary>
                Input code associated with this of this axis or <see cref="F:RavingBots.MultiInput.InputCode.None" />.
            </summary>
        </member>
        <member name="M:RavingBots.MultiInput.IVirtualAxis.Set(System.Single)">
            <summary>
                Sets the next frame value.
            </summary>
            <remarks>
                <note type="important">
                    Remember to <see cref="M:RavingBots.MultiInput.IVirtualAxis.Commit" /> your values.
                </note>
            </remarks>
            <param name="value">Value to set.</param>
        </member>
        <member name="M:RavingBots.MultiInput.IVirtualAxis.Set(System.Boolean)">
            <summary>
                Sets the next frame value. Convenience method for axes representing
                digital buttons.
            </summary>
            <remarks>
                <note type="important">
                    Remember to <see cref="M:RavingBots.MultiInput.IVirtualAxis.Commit" /> your values.
                </note>
            </remarks>
            <param name="held">
                If <c>true</c>, will <see cref="M:RavingBots.MultiInput.IVirtualAxis.Set(System.Single)" /> the axis value to 1. Otherwise,
                will set the value to 0.
            </param>
        </member>
        <member name="M:RavingBots.MultiInput.IVirtualAxis.Add(System.Single)">
            <summary>
                Adds a value to the uncommitted next frame. Convenience method for axes
                that accumulate input in-between frames.
            </summary>
            <param name="value">Value to add.</param>
        </member>
        <member name="M:RavingBots.MultiInput.IVirtualAxis.Commit">
            <summary>
                Commits changes to the next frame.
            </summary>
            <remarks>
                After this method is called, both previous and current values will change.
                <note type="important">
                    This <b>does not</b> clear the uncommitted value, as some axes need to report
                    the same value until they're explicitly reset.
                </note>
            </remarks>
        </member>
        <member name="T:RavingBots.MultiInput.LogLevel">
            <summary>
                Logging level constants.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.LogLevel.DebugVerbose">
            <summary>
                Really verbose messages (used by the debug version of this library).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.LogLevel.Debug">
            <summary>
                Verbose messages (used by the debug version of this library).
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.LogLevel.Info">
            <summary>
                Information messages.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.LogLevel.Warning">
            <summary>
                Warnings.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.LogLevel.Error">
            <summary>
                Errors.
            </summary>
        </member>
        <member name="F:RavingBots.MultiInput.LogLevel.None">
            <summary>
                Highest possible value, used to disable logging.
            </summary>
        </member>
        <member name="T:RavingBots.MultiInput.VirtualAxis">
            <summary>
                Concrete class for custom virtual axes.
            </summary>
        </member>
        <member name="P:RavingBots.MultiInput.VirtualAxis.IsUp">
            <summary>
                <c>true</c> if <see cref="P:RavingBots.MultiInput.VirtualAxis.IsHeld" /> was <c>true</c> in the previous frame
                and isn't in this one.
            </summary>
            <value>If <c>true</c>, this axis has returned to the rest state in the current frame.</value>
        </member>
        <member name="P:RavingBots.MultiInput.VirtualAxis.IsDown">
            <summary>
                <c>true</c> if <see cref="P:RavingBots.MultiInput.VirtualAxis.IsHeld" /> was <c>false</c> in the previous frame
                but isn't in this one.
            </summary>
            <value>If <c>true</c>, this axis has left rest state in the current frame.</value>
        </member>
        <member name="P:RavingBots.MultiInput.VirtualAxis.IsHeld">
            <summary>
                <c>true</c> if this axis is not in the rest state in the current frame
                (i.e. <see cref="P:RavingBots.MultiInput.VirtualAxis.Value" /> is not zero).
            </summary>
        </member>
        <member name="P:RavingBots.MultiInput.VirtualAxis.HasChanged">
            <summary>
                <c>true</c> if value on this axis has changed from the previous frame.
            </summary>
        </member>
        <member name="P:RavingBots.MultiInput.VirtualAxis.Value">
            <summary>
                Value on this axis in the current frame.
            </summary>
        </member>
        <member name="P:RavingBots.MultiInput.VirtualAxis.PreviousValue">
            <summary>
                Value on this axis in the previous frame.
            </summary>
        </member>
        <member name="P:RavingBots.MultiInput.VirtualAxis.NextValue">
            <summary>
                Uncommitted value on this axis for the next frame. May change multiple times
                during a single frame until <see cref="M:RavingBots.MultiInput.VirtualAxis.Commit">committed</see>.
            </summary>
        </member>
        <member name="P:RavingBots.MultiInput.VirtualAxis.Code">
            <summary>
                <see cref="T:RavingBots.MultiInput.InputCode" /> associated with this axis, if any. Informative only.
            </summary>
        </member>
        <member name="M:RavingBots.MultiInput.VirtualAxis.#ctor(RavingBots.MultiInput.InputCode)">
            <summary>
                Constructs a new virtual axis, optionally setting <see cref="P:RavingBots.MultiInput.VirtualAxis.Code" /> property.
            </summary>
            <param name="code">Input code to set <see cref="P:RavingBots.MultiInput.VirtualAxis.Code" /> property to, or <c>null</c>.</param>
        </member>
        <member name="M:RavingBots.MultiInput.VirtualAxis.Set(System.Single)">
            <summary>
                Sets the next frame value.
            </summary>
            <remarks>
                <note type="important">
                    Remember to <see cref="M:RavingBots.MultiInput.VirtualAxis.Commit" /> your values.
                </note>
            </remarks>
            <param name="value">Value to set.</param>
        </member>
        <member name="M:RavingBots.MultiInput.VirtualAxis.Set(System.Boolean)">
            <summary>
                Sets the next frame value. Convenience method for axes representing
                digital buttons.
            </summary>
            <remarks>
                <note type="important">
                    Remember to <see cref="M:RavingBots.MultiInput.VirtualAxis.Commit" /> your values.
                </note>
            </remarks>
            <param name="held">
                If <c>true</c>, will <see cref="M:RavingBots.MultiInput.VirtualAxis.Set(System.Single)" /> the axis value to 1. Otherwise,
                will set the value to 0.
            </param>
        </member>
        <member name="M:RavingBots.MultiInput.VirtualAxis.Add(System.Single)">
            <summary>
                Adds a value to the uncommitted next frame. Convenience method for axes
                that accumulate input in-between frames.
            </summary>
            <param name="value">Value to add.</param>
        </member>
        <member name="M:RavingBots.MultiInput.VirtualAxis.Commit">
            <summary>
                Commits changes to the next frame.
            </summary>
            <remarks>
                After this method is called, both previous and current values will change.
                <note type="important">
                    This <b>does not</b> clear the uncommitted value, as some axes need to report
                    the same value until they're explicitly reset.
                </note>
            </remarks>
        </member>
    </members>
</doc>
